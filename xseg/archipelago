#!/usr/bin/env python
#
# archipelagos tool

import os, sys, subprocess, argparse, time, psutil, signal, socket
from subprocess import call, check_call

BIN_PATH="/usr/bin"
PIDFILE_PATH="/var/run/archipelago"

DEVICE_PREFIX="/dev/xsegbd"
XSEGBD_SYSFS="/sys/bus/xsegbd/"

CHARDEV_NAME="/dev/segdev"
CHARDEV_MAJOR=60
CHARDEV_MINOR=0

SPEC="segdev:xsegbd:512:1024:12"
#REQS=512
#PORTS=512

BPORT=""
MPORT=1
MBPORT=2
VTOOL=3
VPORT_START=204
VPORT_END=403

LOGS_PATH=""

BLOCKER=""
MAPPER=""
VLMC=""

NR_OPS_BLOCKERB=""
NR_OPS_BLOCKERM=""
NR_OPS_VLMC=""
NR_OPS_MAPPER=""

VERBOSITY_BLOCKERB=""
VERBOSITY_BLOCKERM=""
VERBOSITY_MAPPER=""
VERBOSITY_VLMC=""

FILED_IMAGES=""
FILED_MAPS=""

PITHOS=""
PITHOSMAPS=""

RADOS_POOL_MAPS=""
RADOS_POOL_BLOCKS=""
STORAGE="File"

try:
    execfile(os.path.expanduser("/etc/default/archipelago"), globals())
except:
    print "Cannot open defaults"
    sys.exit(1)

HOSTNAME=socket.gethostname()

if BLOCKER == "pfiled":
    peer_blockerb = [BLOCKER,
            ["-p" , str(BPORT), "-g", str(SPEC), "-n", str(NR_OPS_BLOCKERB),
             str(PITHOS), str(FILED_IMAGES), "-d",
            "-f", os.path.join(PIDFILE_PATH, "blockerb.pid")],
            "blockerb"]
    peer_blockerm = [BLOCKER,
            ["-p" , str(MBPORT), "-g", str(SPEC), "-n", str(NR_OPS_BLOCKERM),
            str(PITHOSMAPS), str(FILED_MAPS), "-d",
            "-f", os.path.join(PIDFILE_PATH, "blockerm.pid")],
            "blockerm" ]
else:
    peer_blockerb = [BLOCKER,
            ["-p" , str(BPORT), "-g", str(SPEC), "-n", str(NR_OPS_BLOCKERB),
             "--pool", str(RADOS_POOL_BLOCKS), "-v", str(VERBOSITY_BLOCKERB),
             "-d", "--pidfile", os.path.join(PIDFILE_PATH, "blockerb.pid"),
             "-l", os.path.join(str(LOGS_PATH), "blockerb-"+HOSTNAME+".log"),
             "-t", "3"],
             "blockerb"]
    peer_blockerm = [BLOCKER,
            ["-p" , str(MBPORT), "-g", str(SPEC), "-n", str(NR_OPS_BLOCKERM),
             "--pool", str(RADOS_POOL_MAPS), "-v", str(VERBOSITY_BLOCKERM),
             "-d", "--pidfile", os.path.join(PIDFILE_PATH, "blockerm.pid"),
             "-l", os.path.join(str(LOGS_PATH), "blockerm-"+HOSTNAME+".log"),
             "-t", "3"],
             "blockerm"]

peer_vlmcd = [VLMC,
         ["-t" , "1", "-sp",  str(VPORT_START), "-ep", str(VPORT_END),
          "-g", str(SPEC), "-n", str(NR_OPS_VLMC), "-bp", str(BPORT),
          "-mp", str(MPORT), "-d", "-v", str(VERBOSITY_VLMC),
          "--pidfile", os.path.join(PIDFILE_PATH, "vlmcd.pid"),
          "-l", os.path.join(str(LOGS_PATH), "vlmc-"+HOSTNAME+".log")
          ], "vlmcd"]
peer_mapperd = [MAPPER,
         ["-t" , "1", "-p",  str(MPORT), "-mbp", str(MBPORT),
          "-g", str(SPEC), "-n", str(NR_OPS_MAPPER), "-bp", str(BPORT), "-d",
          "--pidfile", os.path.join(PIDFILE_PATH, "mapperd.pid"),
          "-v", str(VERBOSITY_MAPPER),
          "-l", os.path.join(str(LOGS_PATH), "mapperd-"+HOSTNAME+".log")
          ], "mapperd"]

peers = [peer_blockerb, peer_blockerm, peer_vlmcd, peer_mapperd]
modules = ["xseg", "segdev", "xseg_posix", "xseg_pthread", "xseg_segdev"]
xsegbd = "xsegbd"

def check_conf():
    def isExec(file_path):
        return os.path.isfile(file_path) and os.access(file_path, os.X_OK)

    def validExec(program):
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if isExec(exe_file):
                return True
        return False


    def validPort(port, limit, name):
        try:
            if int(port) >= limit:
                print str(port) + " >= " + limit
                return False
        except:
            print "Invalid port "+name+" : " + str(port)
            return False

        return True


    for p in [BLOCKER, MAPPER, VLMC]:
        if not validExec(p):
            print p + "is not a valid executable"
            return False

    if not LOGS_PATH:
        print "LOGS_PATH is not set"
        return False
    if not PIDFILE_PATH:
        print "PIDFILE_PATH is not set"
        return False

    try:
        if not os.path.isdir(str(LOGS_PATH)):
            print "LOGS_PATH "+str(LOGS_PATH)+" does not exist"
            return False
    except:
        print "LOGS_PATH doesn't exist or is not set"
        return False

    try:
        if not os.path.isdir(str(PIDFILE_PATH)):
            print "PIDFILE_PATH "+str(PIDFILE_PATH)+" does not exist"
            return False
    except:
        print "PIDFILE_PATH or is not set"
        return False

    splitted_spec = str(SPEC).split(':')
    if len(splitted_spec) < 5:
        "Invalid spec"
        return False

    xseg_type=splitted_spec[0]
    xseg_name=splitted_spec[1]
    xseg_ports=int(splitted_spec[2])
    xseg_heapsize=int(splitted_spec[3])
    xseg_align=int(splitted_spec[4])

    if xseg_type != "segdev":
        print "Segment type not segdev"
        return False
    if xseg_name != "xsegbd":
        print "Segment name not equal xsegbd"
        return False
    if xseg_align != 12:
        print "Wrong alignemt"
        return False

    for v in [VERBOSITY_BLOCKERB, VERBOSITY_BLOCKERM, VERBOSITY_MAPPER,
                    VERBOSITY_VLMC]:
         if v is None:
             print "Verbosity missing"
         try:
             if (int(v) > 3 or int(v) < 0):
                 print "Invalid verboisity " + str(v)
                 return False
         except:
             print "Invalid verboisity " + str(v)
             return False

    for n in [NR_OPS_BLOCKERB, NR_OPS_BLOCKERM, NR_OPS_VLMC, NR_OPS_MAPPER]:
         if n is None:
             print "Nr ops missing"
         try:
             if (int(n) <= 0):
                 print "Invalid nr_ops " + str(n)
                 return False
         except:
             print "Invalid nr_ops " + str(n)
             return False

    if not validPort(VTOOL, xseg_ports, "VTOOL"):
        return False
    if not validPort(MPORT, xseg_ports, "MPORT"):
        return False
    if not validPort(BPORT, xseg_ports, "BPORT"):
        return False
    if not validPort(MBPORT, xseg_ports, "MBPORT"):
        return False
    if not validPort(VPORT_START, xseg_ports, "VPORT_START"):
        return False
    if not validPort(VPORT_END, xseg_ports, "VPORT_END"):
        return False
#if filed
    if STORAGE == "File":
        if FILED_IMAGES and not os.path.isdir(str(FILED_IMAGES)):
             print "FILED_IMAGES invalid"
             return False
        if FILED_MAPS and not os.path.isdir(str(FILED_MAPS)):
             print "FILED_PATH invalid"
             return False
        if PITHOS and not os.path.isdir(str(PITHOS)):
             print "PITHOS invalid " 
             return False
        if PITHOSMAPS and not os.path.isdir(str(PITHOSMAPS)):
             print "PITHOSMAPS invalid"
             return False


    return True

if not check_conf():
    sys.exit(1)

def exclusive(fn):
    def exclusive_args(args):
        file = "/tmp/vlmc_map.lock"
        while True:
            try:
                fd = os.open(file, os.O_CREAT|os.O_EXCL|os.O_WRONLY)
                break;
            except Exception, reason:
                print >> sys.stderr, reason
                time.sleep(0.05)
        try:
            r = fn(args)
        finally:
            os.close(fd)
            os.unlink(file)
        return r

    return exclusive_args

@exclusive
def vlmc_showmapped(args):
    try:
        devices = os.listdir(os.path.join(XSEGBD_SYSFS, "devices/"))
    except:
        return -1

    if not devices:
        return -1
    print "id\tpool\timage\tsnap\tdevice"
    try:
        for f in devices:
            d_id = open(XSEGBD_SYSFS + "devices/" + f + "/id").read().strip()
            target = open(XSEGBD_SYSFS + "devices/"+ f + "/target").read().strip()

            print "%s\t%s\t%s\t%s\t%s" % (d_id, '-', target, '-', DEVICE_PREFIX +
            d_id)
    except Exception, reason:
        print >> sys.stderr, reason
        return -2
    return len(devices)

def loadrc(rc):
    try:
        if rc == None:
            execfile(os.path.expanduser("/etc/default/archipelago"), globals())
        else:
            execfile(rc, globals())
    except:
        print "Cannot read config file"
        sys.exit(1)

    if not check_conf():
        sys.exit(1)

def loaded_modules():
    lines = open("/proc/modules").read().split("\n")
    modules = [f.split(" ")[0] for f in lines]
    return modules

def loaded_module(name):
    return name in loaded_modules()

def load_module(name):
    modules = loaded_modules()
    if name in modules:
        return 0
    cmd = ["modprobe -v %s" % name]
    print cmd
    try:
        check_call(cmd, shell=True);
    except Exception:
            sys.stderr.write("Module %s failed to load. \n" % name)
            return -1
    return 0

def unload_module(name):
    modules = loaded_modules()
    if name not in modules:
        return 0
    cmd = ["modprobe -rv %s" % name]
    print cmd
    try:
        check_call(cmd, shell=True);
    except Exception:
            sys.stderr.write("Module %s failed to unload. \n" % name)
            return -1
    return 0

def create_segment():
    #fixme blocking....
    cmd = ["xseg", str(SPEC), "create"]
    try:
        check_call(cmd, shell=False);
    except Exception:
            sys.stderr.write("Cannot create segment. \n")
            return -1
    return 0

def destroy_segment():
    #fixme blocking....
    cmd = ["xseg", str(SPEC), "destroy"]
    try:
        check_call(cmd, shell=False);
    except Exception:
            sys.stderr.write("Cannot destroy segment. \n")
            return 0
    return 0

def check_running(name, pid = -1):
    for p in psutil.process_iter():
        if p.name == name:
            if pid != -1:
                if pid == p.pid:
                    return pid
            else:
                return pid
    return -1

def check_pidfile(name):
    pidfile = os.path.join(PIDFILE_PATH, name + ".pid")
    pf = None
    try:
        pf = open(pidfile, "r")
        pid = int(pf.read())
        pf.close()
    except:
        if pf:
            pf.close()
        return -1

    return pid

def start_peer(peer):
    cmd = [peer[0]] + peer[1]
    try:
        check_call(cmd, shell=False);
    except Exception:
        sys.stderr.write("Peer %s start failed.\n" % peer[0])
        return -1
    return 0

def stop_peer(peer):
    pid = check_pidfile(peer[2])
    if pid < 0:
        print " process not running"
        return -1

    os.kill(pid, signal.SIGTERM)
    i = 0
    while check_running(peer[0], pid) > 0:
        time.sleep(0.1)
        i += 1
        if i > 100:
            print "process did not die in 10 secs"
            return -1
    return 0

def peer_running(peer):
    pid = check_pidfile(peer[2])
    if pid < 0:
        return -1

    r = check_running(peer[0], pid)
    if r < 0:
        print "Peer " + peer[2] + " has valid pidfile but does not seem to be active"
    return 0


def make_segdev():
    try:
        os.stat(str(CHARDEV_NAME))
        return -2
    except:
        pass
    cmd = ["mknod", str(CHARDEV_NAME), "c", str(CHARDEV_MAJOR), str(CHARDEV_MINOR)]
    print cmd
    try:
        check_call(cmd, shell=False);
    except Exception:
        sys.stderr.write("Segdev device creation failed. \n")
        return -1
    return 0

def remove_segdev():
    try:
        os.stat(str(CHARDEV_NAME))
    except:
        return -2
    try:
        os.unlink(str(CHARDEV_NAME))
    except:
        sys.stderr.write("Segdev device removal failed. \n")
        return -1


def start(args):
    if status(args) > 0:
        return -1

    for m in modules:
        if load_module(m) < 0:
            stop(args)
            return -1
    time.sleep(0.5)

    if make_segdev() < 0:
        stop(args)
        return -1
    
    time.sleep(0.5)
    
    if create_segment() < 0:
        stop(args)
        return -1
    
    time.sleep(0.5)
    
    for p in peers:
        if start_peer(p) < 0:
            stop(args)
            return -1


    if load_module(xsegbd) < 0:
        stop(args)
        return -1
    return 0

def stop(args):
    #check devices
    if vlmc_showmapped(args) > 0:
        print "Cannot stop archipelago. Mapped volumes exist"
        return -1
    if unload_module(xsegbd):
        return -1
    r = 0
    for p in reversed(peers):
        stop_peer(p)

    remove_segdev()
    
    for m in reversed(modules):
        unload_module(m)

def status(args):
    r = 0
    if vlmc_showmapped(args) >= 0:
        r += 1
    if loaded_module(xsegbd):
        print "Xsegbd loaded"
        r += 1
    else:
        print "Xsegbd not loaded"
    for m in reversed(modules):
        if loaded_module(m):
            print m + " loaded"
            r += 1
        else:
            print m + " not loaded"
    for p in reversed(peers):
        if peer_running(p) < 0:
            print p[0] + " not running"
        else:
            print p[0] + " running"
            r += 1
    return r
  
def restart(args):
    stop(args)
    start(args)

if __name__ == "__main__":
    # parse arguments and discpatch to the correct func
    parser = argparse.ArgumentParser(description='vlmc tool')
    parser.add_argument('-c', '--config', type=str, nargs='?', help='config file')
    subparsers = parser.add_subparsers()

    start_parser = subparsers.add_parser('start', help='Start archipelago')
    start_parser.set_defaults(func=start)
    
    stop_parser = subparsers.add_parser('stop', help='Stop archipelago')
    stop_parser.set_defaults(func=stop)
    
    status_parser = subparsers.add_parser('status', help='Archipelago status')
    status_parser.set_defaults(func=status)
    
    restart_parser = subparsers.add_parser('restart', help='Restart archipelago')
    restart_parser.set_defaults(func=restart)

    args = parser.parse_args()
    args.func(args)
